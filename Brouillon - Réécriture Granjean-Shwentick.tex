\documentclass{article}

\include{packages}
\include{macros}

% Pour les itemize : 			\setlength{\itemsep}{-1mm}

% Variables pour le document

\author{BEURIER Erwan}
\title{M2 LFMI \\ BROUILLON }
\date{Année 2015-2016}

% Commandes de ce document

\newcommand{\sRAMif}[2]{\text{IF} (A=B) \{I( #1 )\} \text{ ELSE } \{I( #2 )\}}
\newcommand{\sRAMifc}[2]{\text{IF} (A_1=A_2) \{I( #1 )\} \text{ ELSE } \{I( #2 )\}}
\newcommand{\bbA}{\mathbb{A}}
\newcommand{\TRec}[1]{\text{TRec}\left(\mathbb{#1}\right)}
\newcommand{\TRecd}[1]{\text{TRec}_{2}\left(\mathbb{#1}\right)}
\newcommand{\dtimeram}{\text{DTIME}_{\text{RAM}}\left( \grozo{ n^k }\right)}
\newcommand{\eqpred}[3]{#1\left[ #2^{\leftarrow}(#3) \right]_{#3}}
\newcommand{\eqpredf}[4]{#1\left[ #2^{\leftarrow}(#3) \right]_{#4}} % four arguments
\newcommand{\eqpredfi}[5]{#1\left[ #2^{\leftarrow}(#3) #4 \right]_{#5}} % five arguments


\begin{document}
	
	
	\paragraph{README}
	
	Ce fichier n'est qu'un brouillon de réécriture de l'article de Grandjean et Schwentick \emph{Machine-independent characterizations and complete problems for deterministic linear time} pour voir si ces notions peuvent s'étendre au temps $\grozo{n^k}$.
	
	C'est plus ou moins une traduction littérale en français et en remplaçant $\grozo{n}$ par $\grozo{n^k}$, pour voir si ça coince à un endroit.
	
	
	\paragraph{Notations}
	
	Par abus de notation découlant de la théorie des ensembles, j'écrirai $n$ pour $\intint{0}{n-1}$ voire pour $\intint{1}{n}$ quand il n'y aura pas d'ambiguïté. De manière générale, si un terme ressemble à un entier naturel mais qu'il est mis à la place d'un ensemble (typiquement, dans une fonction), il faut le lire comme l'ensemble $\intint{0}{n-1}$.
	
	\pagebreak
	
	\paragraph{Preliminaries} (p.198)
	
		\subparagraph{RAM data structures} (p.198)
	

		\begin{definition}[RAM data structures]
			Soit $t$ un type, c'est-à-dire une signature fonctionnelle ne contenant que des symboles de constantes ou de fonctions unaires.
			
			Une RAM-structure $s$ de type $t$ est un uplet constitué de :
			\begin{itemize}
				\setlength{\itemsep}{-1mm}
				\item 	$n \in \naturels$ est la taille de la structure ;
				\item 	$C \in \naturels$ pour chaque symbole $C \in t$ ;
				\item 	$f : n \to \naturels$ pour chaque symbole $f \in t$.
			\end{itemize}
			
			On notera $s.n, s.C, s.f$ les composantes $n, C, f$ de $s$ (cette notation est à rapprocher de l'accès à un attribut ou à une fonction membre en programmation objet).
			
			On dira que $s$ est $c$-bornée pour $c\in\naturels$ lorsque $s.C, s.f(i) < c s.n$ pour tous $C, f \in t$ et $i \in n$.
		\end{definition}
	
	
		\begin{definition}[Fonction de RAM]
			Soient $t_1, t_2$ des types. 
			
			Une $(t_1, t_2)$-fonction de RAM $\Gamma$ est une fonction telle qu'il existe $c_1, c_2 \in \naturels$, tels que $\Gamma$ envoie les structures $c_1$-bornées de type $t_1$ sur des structures $c_2$-bornées de type $t_2$.
			
			% On rappelle que "c-borné" ne concerne que la structure par rapport à sa propre taille ; ici on ne compare pas la taille de l'entrée et de la sortie
			
			On dit que $\Gamma$ est polynomiale lorsque $\Gamma(s).n = \grozo{(s.n)^k}$.
			
			% Là, si.
		\end{definition}
	
	
	
		\subparagraph{Machine RAM} (p.200)
	
		
		La machine RAM reste la même (heureusement). On va utiliser la $\{+\}$-RAM ou des versions un brin plus puissantes comme la $\{+ , -, \times, \div k \}$-RAM pour un $k\in \naturels$ fixé.
		
		\begin{definition}[Temps polynomial]
			On définit $\dtimeram$ comme étant l'ensemble des fonctions calculables sur $\{+\}$-RAM en temps $\grozo{n^k}$, telles que le nombre de registres utilisés, la longueur des nombres manipulés (y compris les adresses de registres) soient bornés par $\grozo{n^k}$.
		\end{definition}
		
		
		
		\subparagraph{Réductions affines} (p.202)


		On laisse inchangées les notions de \emph{transformations affines} (définition 2.3), de \emph{réductions affines} (définition 2.5),de projections affines (définition 2.7). Les théorèmes et lemmes suivants ou intermédiaires sont aussi inchangés. Ils permettront de définir des réductions qui \emph{restent} dans $\dtimeram$ pour un $k$ fixé.
		
		
		
	\paragraph{Le framework algébrique} (p.208)


		\subparagraph{LSRS} (p.208)
		
		
		Le LSRS en tant que tel n'a pas l'air collé à la définition du temps linéaire. On garde la définition pour le moment. 
		
		On doit refaire la définition 3.3.
		
		Pour $t$ un type, on note $F_t$ l'ensemble de symboles de fonctions suivants : $\{1(-), n(-), id(-)\} \cup  \{ f_C | C \in t\} \cup \{ f | f \in t\}$.
		
		\begin{remark}
			Soient $t$ un type et $S$ un LSRS pour $f_1, \dots, f_h$ sur $F_{t}$. 
			L'entrée d'un LSRS peut être vue comme étant une RAM-structure $s$ de type $t$, qu'il \emph{lit} en interprétant les symboles de $F_t$ de la façon suivante : 
			
			\begin{itemize}
				\item 	$\forall f \in t_1$ :   $f(i) = 
				\left\lbrace \begin{array}{ll}
				s.f(i) & \text{si } i< s.n \\
				0 & \text{sinon}
				\end{array}\right.$
				
				\item 	$\forall C \in t_1$ :   $f_C(i) = s.C$
				\item 	$1(i) = 1, n(i) = s.n, id(i) = i$
			\end{itemize}
			
			La sortie du LSRS peut aussi être vue comme une nouvelle structure $s' = S(s)$ de type $\{f_1, \dots, f_h\}$.
		\end{remark}
		
		
		Ici, on a plusieurs possibilités pour adapter le concept de \emph{linéairement représenté} (définition 3.3) à $n^k$.
		
		\begin{definition}[RAM $n^k$-représentée par LSRS - Proposition 1]
			Soient $t_1, t_2$ des types. Soit $\Gamma$ une $(t_1, t_2)$-fonction de RAM. 
			
			Soit $S$ un LSRS pour $f_1, \dots, f_h$ sur $F_{t_1}$. 
			
			On dit que $\Gamma$ est $n^k$-représentée par $S$ lorsqu'il existe un entier $c$ et une projection affine $P$ tels que, pour chaque structure $s$ $c$-bornée, $S$ définit des fonctions $f_1, \dots, f_h : c (s.n)^k \to c (s.n)^k$ telles que $\Gamma(s) = P((s.n)^k, S(s))$ ($S(s)$ est la structure définie par le LSRS).
			
			\emph{La modification réside dans le domaine de définition des fonctions et la taille de la sortie dans la projection.}
		\end{definition}
			
		
		\begin{probs} \textcolor{white}{T} % Obligé pour sauter une ligne.
			\begin{itemize}
				\setlength{\itemsep}{-1mm}
				\item 	Est-ce qu'on capture tout $\dtimeram$ ? 
				\item 	Est-ce que $P((s.n)^k, S(s))$ capture toutes les structures de taille $\grozo{n^k}$ ?
			\end{itemize}
		\end{probs}
			
	
		Si $\Gamma$ est $n^k$-représentée par un LSRS alors on dit que $\Gamma$ est définissable par LSRS. 
		
		
		% Eventuellement d'autres possibilités
		
		La définition 3.4 (définition par cas) et les lemmes 3.5 (la définition par cas ne change pas la puissance des LSRS) et 3.6 (composition de fonctions définissables par LSRS reste définissable par LSRS) restent les mêmes.
		
		
		\subparagraph{LRS} (p.211)
		
		La définition d'un terme récursif (non numérotée) et d'un LRS (définition 3.7) restent les mêmes. Le lemme 3.8 d'existence d'une solution unique au LRS aussi. 
		
		On doit adapter la définition de $n^k$-représentée par LRS : 
		
		\begin{definition}[RAM $n^k$-représentée par LRS - Proposition 1]
			Soit $\Gamma$ une fonction de RAM. 
			
			Soit $E$ un LSRS $g(x) = \sigma(x)$. 
			
			On dit que $\Gamma$ est $n^k$-représentée par $E$ lorsqu'il existe un entier $c$ et une projection affine $P$ tels que, pour chaque structure $s$ $c$-bornée, $E$ définit une fonction $g : c (s.n)^k \to c (s.n)^k$ telle que $\Gamma(s) = P((s.n)^k, E(s)$ ($E(s)$ est la structure définie par le LRS, elle est de type $\{g\}$).
			
			\emph{La modification réside dans le domaine de définition de $g$.}
		\end{definition}
		
		Et là, c'est la foire.
		
		On doit vérifier si le théorème principal de l'article tient encore au temps polynomial.
		
		
		
		\begin{conj}[Adaptation du lemme 3.10 (p.212)]
			Toute fonction de RAM $n^H$-représentée par LSRS est aussi $n^H$-représentable par LRS.
		\end{conj}
		
		\begin{proof}
			Ici commence la relecture de la preuve.
			
			Soit $\Gamma$ une fonction de RAM $n^H$-représentée par un LSRS $S$ sur $F_{t_1}$ pour $f_0, \dots, f_{k-1}$, comme dans la définition, et soit $P$ la projection affine associée. Soit $s$ une RAM-structure $c$-bornée de type $t_1$. On note $s' = S(s)$ la structure définie par $S$ avec entrée $s$, et on note $s'' = \Gamma(s) = P\left( (s.n)^H, s'\right)$. Pour simplifier les notations, on va simplement écrire $n$ au lieu de $s.n$.
			
			L'idée est de coder les fonctions $f_0, \dots, f_{k-1} : cn^H \to cn^H$ par une unique fonction $g$. Pour s'assurer que la fonction \emph{Equal-Predecessor} fonctionne correctement, le codage des $f_i$ doit avoir des domaines disjoints et des images disjointes. Cela peut se faire, pour chaque $i<k$, en n'utilisant que des valeurs congrues à $i$ modulo $k$ pour la fonction $f_i$. Puisqu'on va en avoir besoin pour coder/décoder les opérations, on va aussi coder la fonction $\div k$ dans $g$.\\
			
			On va étendre le domaine de $g$ pour encoder $\Gamma(s).f$ pour chaque symbole de fonction $f$ du type de la structure de sortie, \emph{by function values of a contiguous interval} (???).
			
			Précisément, $g$ va être définie sur $2kcn^H$ de sorte que :
			
			\begin{itemize}
				\setlength{\itemsep}{-1mm}
				\item	pour tout $b \in kcn^H$, on a $g(b) = b \div k$ ;
				\item 	pour tous $a \in cn^H$ et $i \in k$, on a $g\left( kcn^H + ka + i \right) = kcn^H + k f_i(a) + i$ $\textcolor{red}{(\star)}$
			\end{itemize}
			
			En d'autres termes, pour $b \geqslant kcn^H$ et $b \mod{k} = j$, on a $g(b) = kcn^H + k f_j\left( (b-kcn^H) \div k \right) + j$.
			On va définir la valeur de $g(b)$ pour $b \in 2kcn^H$ par distinction de cas sur $b \mod{k}$, comme décrit dans (1) à (3) ci-dessous.
			
			\begin{itemize}
				\setlength{\itemsep}{-1mm}
				
				\item 	
						Renumérotons les symboles de $F_{t_1} = \{f | f \in t_1\} \cup \{f_C | C \in t_1\} \cup \{1(-), n(-), id(-)\}$ ainsi $\{ f^0, \dots, f^{l-1} \}$. On va limiter les occurrences de ces symboles. Premièrement, les symboles $f_0, \dots, f_{k-1}$ sont remplacés par $f^{l}, \dots, f^{l+k-1}$ respectivement. Ensuite, On va introduire $l$ nouvelles fonctions $f_0, \dots, f_{l-1}$ et $l$ équations pour les définir :
							
							\subitem	Si $f^i$ vient de $t_1$, alors l'équation associée est $f_i(x) = f^i(x)$ ;
							\subitem 	Si $f^i = id$, alors l'équation associée est $f_i(x) = x$ ;
							\subitem 	Si $f^i = f_C$, ou $1$ ou $n$, alors l'équation associée est (respectivement) $f_i(x) = C, 1, n$. 
					
						% Subitem ne marche pas ?
						
						On appellera ces équations des \emph{équations d'entrée} ; elles servent justement à remplacer les entrées du LSRS.
						
						Enfin, on remplace dans le LSRS $S$ tous les anciens symboles de fonctions (ceux de $F_{t_1}$) par les nouveaux (les $(f_i)_{i \in l+k}$). Après ces remplacements, $S$ ne contient plus aucune référence à $F_{t_1}$, sauf pour les équations d'entrée. 
					
				\item 	
						Les équations de $S$ sont combinées en une seule équation $g(y) = \sigma(y)$ comme suit. Le terme $\sigma(y)$ est principalement une distinction de cas dépendant de $y$ et $y \mod{k}$. 
					
						\[
							g(y) = 
								\left\lbrace \begin{array}{ll}
									0 				& \text{si $y \leqslant k-1$} \\
									g(y-k) + 1 		& \text{si $k \leqslant y < kcn^H$} \\
									\sigma_i(y)		& \text{si $y \geqslant kcn^H$ et $y \mod{k} = i$}
								\end{array}\right.
						\]
						
						où $\sigma_i(y)$ est un terme récursif qu'on explicitera tout de suite après. 
						
						Notons que les deux premiers cas donnent $g(y) = y \div k$ pour chaque $y < kcn^H$, comme voulu. Cela nous permet d'exprimer $y \mod{k}$ pour $kcn^H \leqslant y < 2kcn^H$, puisque $(y-kcn^H) - kg(y-kcn^H) = (y-kcn^H) - \sum_{j=1}^{k} g(y-kcn^H)$. \redtext{(Et alors ???)}
						
						Ensuite, on a vu que la distinction de cas ne rendait pas le LSRS plus puissant. 
						
						Enfin, on décrit la construction des termes de récurrence $\sigma_i(y)$ (on distingue la variable $y$ du terme de récurrence, de la variable $x$ des équations) :
					
						\subitem $\bullet$	
								Si $E_i$ est une équation d'entrée, alors $\sigma_i(y)$ est construit comme suit :
						
						
								\subsubitem -		
									Si le terme de droite de l'équation est une constante $C$ (éventuellement $1$ ou $n$), alors $\sigma_i(y) = kcn^H + kC + i$ ;

								\subsubitem	-	
									Si le terme de droite de l'équation est $x$, alors $\sigma_i(y) = kcn^H + kg\left( y - kcn^H \right) + i$ ;
								
								\subsubitem	-	
									Si le terme de droite de l'équation est $f^i(x)$, alors $\sigma_i(y) = kcn^H + k f^i\left( g\left( y - kcn^H \right) \right) + i$.
									
								Justifions pourquoi cette définition de $\sigma_i(y)$ est correcte. On le fait pour le troisième cas ; les deux autres sont plus simples. Soit $b = kcn^H + ka + i$ avec $a < cn^H$. Alors $g(b-kcn) = g(ka + i) = (ka + i) \div k = a$, et $\sigma_i(b) = kcn^H + kf^i(a) + i$, comme voulu. 
				
						\subitem $\bullet$	
								Si $E_i$ est de la forme $f_i(x) = f_j(x) - f_{j'}(x)$, alors $\sigma_i(y)$ est défini par :
								
								\[
									\sigma_i(y) = \left( g(y - \delta) - k cn^H - j \right) - \left( g(y - \delta') - k cn^H - j' \right) + kcn^H + i
								\]
								
								où $\delta = i -j$ et $\delta' = i - j'$ et, par définition d'un LSRS, $i > j, j'$. Pour vérifier que cette expression est correcte, soient $a \in cn^H$, $b = kcn + ka + i$, où $i<k$. Si $g(b - \delta) = g(kcn^H + ka + j) = kcn^H + kf_j(a) + j$ et $g(b - \delta') = g(kcn^H + ka + j') = kcn^H + kf_{j'}(a) + j'$ alors :
								
								\[
									\left( g\left( b - \delta \right) - kcn^H - j \right) - \left( g\left( b - \delta' \right) - kcn^H - j' \right)
									=  k \left( f_{j}(a) - f_{j'}(a) \right) + kcn^H + i
								\]

								
								Ce qui est ce qu'on voulait.
								
						\subitem $\bullet$
								Si $E_i$ est de la forme $f_i(x) = f_j(x) + f_{j'}(x)$, alors son traitement est similaire au cas précédent, à ceci près qu'il faut que l'addition $x + y$ renvoie $0$ si $x + y > cn^H$. On redéfinit alors $\sigma_i(y)$ : 
								
								\[
									\sigma_i(y) = \casedist{
										\tau(y) + kcn^H + i & \text{si $\tau(y) < kcn^H$} \\
										kcn^H + i & \text{sinon}
										}
								\]
								
								où $\tau(y) = \left( g\left( b - \delta \right) - kcn^H - j \right) - \left( g\left( b - \delta' \right) - kcn^H - j' \right)$ avec $\delta = i - j$ et $\delta' = i - j'$. 
								
								La vérification se passe de la même manière que précédemment.
								
						\subitem $\bullet$
								Si $E_i$ est de la forme $f_i(x) = \eqpred{f_{j'}}{f_j}{x}$, où $j < i$ et on suppose sans perte de généralité que $i \leqslant j'$ 
									\footnote{Si $i > j'$ alors on doit rajouter une nouvelle fonction $f_l$ à $S$, telle que $l > i$, et définie par la nouvelle équation $f_l(x) = f_{j'}$ et remplacer $E_i$ par $f_i(x) = \eqpred{f_{l}}{f_j}{x}$}
								, alors $\sigma_i(y)$ est définie par :
								
								\[
									\sigma_i(y) = \eqpredfi{g}{g}{y-\delta}{ + \delta'}{y} - j' + i
								\]
								
								où $\delta = i - j$ et $\delta' = j' - j$.
								
								Pour justifier ce remplacement, on doit s'assurer que le codage de plusieurs fonctions en une seule ne cause par d'effets de bord quand on utilise \emph{Equal-Predecesor}. Ce qui est crucial ici, c'est que, pour chaque $i<k$, les valeurs de $g$ qui codent $f_i$ soient congruentes à $i$ modulo $k$. Pour être plus précis, soit $b = kcn^H + ka + i$, avec $a< cn^H$. Alors $b-\delta = kcn^H + ka + i - (i - j) \underset{i>j}{=} kcn^H + ka + j$. On a deux sous-cas à étudier :
								
								\subsubitem -
										$f_j^{\leftarrow}(a) = a$.   Dans ce cas, pour aucun $a' < a$, on n'a $f_j(a') = f_j(a)$, donc il n'y a pas de $a' < a$ pour lequel $g\left( kcn^H + ka' + j \right) = g\left( kcn^H + ka + j \right)$. La définition de $g$ assure que, pour chaque $e \geqslant kcn^H$, on a $\left(g(e) \mod{k} = j \Leftrightarrow e \mod{k} = j\right)$ et $\forall e, e' \in 2kcn^H$, si $g(e) = g(e')$, alors soit $e, e' < kcn^H$, soit $e, e' \geqslant kcn^H$. Donc $g^{\leftarrow} \left( kcn^H + ka + j \right) = kcn^H + ka + j$ et $g^{\leftarrow}\left( b - \delta \right) + \delta' = kcn^H + ka + j' \geqslant kcn^H + ka + i = b$. Ainsi :
										
										\setcounter{equation}{0}
										\begin{eqnarray}
											\sigma_i(b) 	& = &	\eqpredfi{g}{g}{b-\delta}{+\delta'}{b} - j' + i \\
															& = & 	\left( kcn^H + ka + j' \right) - j' + i \\
															& = & 	kcn^H + ka + i \\
															& = & 	kcn^H + k \eqpred{f_{j'}}{f_j}{a} + i \\
															& = & 	kcn^H + k f_i(a) + i \\
															& = & 	g(b),
										\end{eqnarray}
										
										comme voulu.
										
								\subsubitem - 
										$f_j^{\leftarrow}(a) = a'$ pour un certain $a' < a$. Dans ce cas, $g\left( kcn^H + ka + j \right) = kcn^H + ka' + j$. En conséquence : 
										
										\[
											g^{\leftarrow}\left( b - \delta \right) + \delta' = kcn^H + ka' + j' < kcn^H + ka + i = b
										\]
										
										Donc :
										
										\setcounter{equation}{0}
										\begin{eqnarray}
											\sigma_i(b) 	& = &	\eqpredfi{g}{g}{b-\delta}{+\delta'}{b} - j' + i \\
															& = & 	g\left( kcn^H + ka' + j' \right) - j' + i \\
															& = & 	\left( kcn^H + k f_{j'}(a') + j' \right) - j' + i \\
															& = & 	kcn^H + k f_{j'}(a') + j' + i \\
															& = & 	kcn^H + k \eqpred{f_{j'}}{f_j}{a} + i \\
															& = & 	kcn^H + k f_i(a) + i \\
															& = & 	g(b),
										\end{eqnarray}
										
										comme souhaité.
										
				\item	
					Maintenant, on complète le LRS pour $g$. Pour une question de simplicité, on va supposer que $t_2$ ne contient que le symbole de constante $n$ et un seul symbole de fonction $h$. Soient $j <k$ et $\alpha$ une fonction affine tels que, pour toute structure $s$, on ait $\Gamma(s).n = P\left((s.n)^H, s'\right).n = s'.f_j\left(\alpha\left( (s.n)^H \right)\right)$, et soient $i <k$ et $A$ une fonction affine tels que, pour toute structure $s$ et tout $a < \Gamma(s).n$, on ait $\Gamma(s).h(a) = P\left((s.n)^H, s'\right).h(a) = s'.f_i\left(A\left( (s.n)^H, a \right)\right)$
						\footnote{Ça veut juste dire : on donne des noms aux éléments qui permettent de définir la structure $\Gamma(s)$ ; ces fonctions affines $\alpha, A$ et ces entiers $i,j$ existent par définition d'une fonction $n^H$-représentable par un LSRS. Reste à voir si cette définition a bien du sens, mais si ça a du sens, alors il n'y a pas de problème ici.}
					.
					
					On a construit $g$ de telle manière que toutes les valeurs de fonctions $f_i(a)$ sont, en quelque sorte, disponibles dans $g$, mais on a encore deux problèmes à résoudre. Premièrement, les $f_i(a)$ apparaissent uniquement sous une forme codée ; deuxièmement, elles ne forment pas un intervalle contigu mais sont éparpillées modulo $k$. Il faut donc, avant d'extraire les valeurs à l'aide d'une projection affine bien choisie, on doit décoder les valeurs des fonctions et les ramener dans un même intervalle. Pour ça, on élargit le domaine de $g$ à $(2k+2)cn^H$ et on complète la définition de $g$ :
					
					\[
						g(y) = \casedist{
							\text{comme avant} & \text{si $y < 2kcn^H$} \\
							g\left[ g\left[ k\left( y - 2kcn^H \right) + kcn^H  + i\right]_y - kcn^H  \right]_y & \text{si $2kcn^H \leqslant y < (2k+1)cn^H$} \\
							g\left[ g\left[ k\left( y - (2k + 1)cn^H \right) + kcn^H  + j \right]_y - kcn^H  \right]_y & \text{si $(2k+1)cn^H \leqslant y < (2k+2)cn^H$} \\
							}
					\]
					
					Il découle de l'équation \redtext{$(\star)$} (la définition de $g$ sur $kcn^H$) et de cette définition que, pour tout $a < cn^H$, on a
					\footnote{Analysons :
						\begin{itemize}
							\setlength{\itemsep}{-1mm}
							\item	$(1) \rightarrow (2)$ : parce que soustraction propre.
							\item 	$(2) \rightarrow (3)$ : par définition de l'opérateur \emph{application bornée}.
							\item 	$(3) \rightarrow (4)$ : parce que $k a + kcn^H  + i < 2kcn^H$ donc on reprend la définition de la fonction $g$ sur l'intervalle $2kcn^H$.
							\item 	$(4) \rightarrow (5)$ : \emph{because} soustraction propre.
							\item 	$(5) \rightarrow (6)$ : parce que $f_i(a) < cn^H$ et on a le bon décalage avec $i$.
						\end{itemize}	
					} :
					\setcounter{equation}{0}
					\begin{eqnarray}
						g\left( 2kcn^H + a\right)	& = & 		g\left[ g\left[ k\left( \left(2kcn^H + a\right) - 2kcn^H \right) + kcn^H  + i\right]_{2kcn^H + a} - kcn^H  \right]_{2kcn^H + a} \\
													& = & 		g\left[ g\left[ k a + kcn^H  + i\right]_{2kcn^H + a} - kcn^H  \right]_{2kcn^H + a} \\
													& = & 		g\left[ g\left( k a + kcn^H  + i\right) - kcn^H  \right]_{2kcn^H + a} \\
													& = & 		g\left[ \left(kcn^H  +  k f_i(a) + i\right) - kcn^H  \right]_{2kcn^H + a} \\
													& = & 		g\left[ k f_i(a) + i \right]_{2kcn^H + a} \\
													& = & 		f_i(a)
					\end{eqnarray}
					
					De la même manière, on obtient, pour $a < cn^H$, $g\left( (2k+1)cn^H + a\right) = f_j(a)$. 
					
					Maintenant, il est aisé de définir une projection affine $P'$ qui extrait $\Gamma(s)$ à partir de $s'''$ de type $\{g\}$, définie par le LRS :
					\[
						\Gamma(s).n = s'''.g\left( \alpha\left( cn^H\right) + (2k+1)cn^H\right) \footnotemark
					\]
					
						\footnotetext{C'est bien ce qu'il nous faut, parce que $\alpha': a \mapsto \alpha\left(ca\right) + (2k+1)ca$ est bien une fonction affine telle que $P'\left(n^H, s'\right).n = s'''.g\left(\alpha'\left(n^H\right)\right)$.}
					
					et
						\footnote{On rappelle que $s'$ est la structure résultante du LSRS originel, de type $\{f_0, \dots, f_{k-1}\}$, qu'on a compactée dans une seule structure de type $\{g\}$.}
						\footnote{Analysons :
							\begin{itemize}
								\setlength{\itemsep}{-1mm}
								\item 	$(1) \rightarrow (2)$ : par définition de $A$ et $i$.
								\item 	$(2) \rightarrow (3)$ : parce qu'on a $f_i(a) = g\left( 2kcn^H + a \right)$ par construction de $g$.
							\end{itemize}
							}
					 :
					\setcounter{equation}{0}
					\begin{eqnarray}
						\Gamma(s).h(a) 	& = &	P\left( n^H, s' \right).h(a) \\
										& = &	s'.f_i\left( A\left( n^H, a \right) \right) \\
										& = & 	s'''.g\left( 2kcn^H + A\left( n^H, a \right) \right) \footnotemark
					\end{eqnarray}
					
					\footnotetext{C'est bien ce qu'il nous faut parce que $A' : a,b \mapsto 2kcb + A\left( b, a \right)$ est bien une fonction affine telle que $P'\left(n^H, s'\right).h(a) = s'''.g(A'(n^H, a))$.}
					
					
			\end{itemize}
			
		\end{proof}
		
		\subparagraph{Bilan}
		
		La démonstration a l'air de marcher !!
		
		
		
\end{document}

















